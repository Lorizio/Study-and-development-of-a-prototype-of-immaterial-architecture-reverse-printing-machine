## Interface
	
This interface allows to manually draw curve-shaped foam features using drag and drop. Before drawing them, first two default sides have to be constructed. To construct them it is sufficient to fill two text fields with desired number of control points from each side. Using these control points we want to create curve features by again using drag and drop. In order to achieve this goal, for each possible arc between the lower and upper neighbour of any control point a set of intermediate points is created. This set represents half of the ellipse and the more intermediate points there are, the more precise half ellipse we will get. Thus one side of the foam is now represented by two sets of points: one set contains all control points and their neighbours, and another one splits those and represents the discretization of one side. The first array contains
```java
nPoints = nPointsTemp * 2 + 1;
```
elements, where **nPointsTemp** is a number of control points we filled in a text field before, and the second array contains
```java
dataSize = (nPoints / 2) * nPointsProArc + 1;
```
elements, where **nPointsProArc** denotes a number of intermediate points between the lower and upper neighbour of any control point.

Later in Arduino's section we are going to introduce two possible cutting algorithms that make use of these two arrays. The first one will use data from a bigger array with **dataSize** number of elements, whereas the second algorithm will use an array that contains only information about control points.

As soon as two sides have been created it becomes possible to move control points from each side using drag and drop to get any curve-shaped sculpture we want. By moving control points from their origin we want to create half ellipse that is considered to be good approximation for one curve feature. To do this we first defined a parameter
```java
stepAngle = PI/nPointsProArc;
```
which denotes a step, our half ellipse is going to be built with and again, the more intermediate points between the lower and upper neighbour of any control point we have defined, the more precise and good-looking result we will get. Depending on to which side any control point is being moved relatively its origin position, we should define two edge angles that will allow to build half ellipse. If a control point has been moved to the **right**, we use as a **start angle -PI/2** and **end angle PI/2**, whereas if it has been moved to the **left PI/2 as a start angle and 3*PI/2 as end angle**. Using a simple **for loop** and starting from the **start angle**, using as a step **stepAngle**, it is now possible to build half ellipse containing all intermediate points, which coordinates are set using the following relation: 
```java
float x = xC + w * cos(angle);
float y = yC + h * sin(angle);
```
where **xC, yC** are x and y coordinates of the origin, **w** is a distance between x coordinates of the actual position of control point and its origin, and **h** is a distance between y coordinates of two neighbour points. Thus moving of any control point and using above described approach it is feasible to create any curve-shaped form we want. Each **draw()** cycle will completely rewrite the discretization array, filling it with new coordinates of each point
on the curve.

All other principles, which were omitted here like rescaling the pixel coordinates into degrees the step motors should move, are described in the square-shaped sculpture project. Depending on which cutting algorithm is going to be applied, different data is sent to an appropriate Arduino board. As briefly mentioned above, there exist two different algorithms: one uses rapid back-and-forth movements of two step motors, whereas another one uses slow continious and smooth motion of step motors. In the first case the following data is sent: first the rescaled discretization array containing all the target information for step motors is sent. Further, another data block is sent which defines how big a delay should be between handling of two sequential target positions. What it exactly means will be described below. In the second case only one data block is sent,
containing the rescaled information of control points array, representing two sets of target positions in degrees for
both step motors.

## Rapid back-and-forth cutting algorithm
	
As an input this algorithm gets two independent data blocks: array of target positions for a step motor and another array of delay values. The first array discretizes one foam side into a set of target positions, whereas the second one consists of delay values that will be used during sequential handling of target positions. The algorithm is divided into two phases: passive, when two data blocks are being received, and active, when the actual cutting is being done. Let us have a look at the active phase more in detail. In the **setup()** method a step motor is adjusted in such a way that it is able to move to any target position as instant as possible, which is provided by the following setting: **microstepping** is set to **4**, **acceleration** value is set to **29000** and **speed** equals **5000**. 

During active phase of the algorithm we pick one target position and one delay value from appropriate arrays. The step motor moves as quick as possible to this target position. As soon as it has reached it, it starts moving back to the origin position again as instant as possible. When the step motor reaches zero, it stops moving and stays
in this idling mode during time interval, described by the picked delay value. These delay values describe how far in time the target positions are from each other. For example, if the previously introduced parameter **nPointsProArc** was set to a small value, it would have resulted in bigger delays, because we would have less target positions to handle, and vice versa setting that value to a bigger number would result to smaller delays. After a time difference has reached a delay value, the step motor is allowed to handle another target position in the same manner until there are no more positions to work on.

Thus this algorithm tries to neglect time needed to go to any target position and back, by using the configuration which
allows to achieve this, in contrast to the picked delay time. One important aspect to mention is that in order to fill the delay array with correct values, we should precisely know how long it takes for the foam to be fabricated. If we know this value, then cutting procedure will be finished approximately at the same time the foam reaches its maximum in height.

Experimental results were not perfect. Depending on the drawn foam sculpture, the results were either acceptable or not. For some reasons different curve fragments have shown different acceptability level. For example, clockwise curve fragments of the left side were much better recognizable as those which were counter-clockwise. If to consider possible improvements towards higher degree of recognition, they could be: increasing a number of intermediate points for one arc fragment or changing of step motor configuration.

Provided experimental results of this algorithm have become a source of motivation to implement another one, which would deliver much more acceptable results and the below described algorithm is able to achieve this goal.
	
## Slow continious motion cutting algorithm
		
This algorithm implements continious motion of two step motors. Having two sequential target positions, now two step motors instead of doing the sequence go to one target position, go to zero, delay, go to another target position, will slow and smoothly move from one target position to another. This approach thus can be considered as an opposite to the first algorithm.

The very first issue was to make a step motor move very slow, considerably slower than before. To achieve this a set of experiments has been done. First an array containing a small number of target positions to simulate a set of control points was created. During this test a step motor was sequentially handling them as usual, but additionally two time stamps were introduced. During the first one our step motor was allowed to move, whereas during the second one not. Trying different combinations of those it was possible to slown down a motor without changing its speed and acceleration, but the motion itself was not smooth enough to be acceptable. The library's core for a step motor implicitly does this kind of procedure, so implementing this kind of routine explicitly was not acceptable. This lead to make further experiments, but now an attempt was made to reduce the acceleration.

In the second set of experiments the acceleration was sequentially reduced by keeping a small number of target positions. Reducing the acceleration, as expected, made a step motor move significantly slower but one problem arised. If a set of target positions is not dense enough, for example {0, 90, 180, 90, 0}, than reducing only acceleration will not bring expected results. Instead, as a result we will get totally not smooth motion, since using small acceleration will take a lot of time for a step motor to reach its maximum speed and it will take the same amount of time to decelerate from this speed to zero while approaching to the current position. The higher acceleration stays, the smoother motion will be, but not slow enough to get the features with good resolution. The lower acceleration is, the slower motion will be, but smooth motion can not be guaranteed. This lead to do the final set of experiments, which indeed has shown good results.

We will now keep reducing the acceleration, but now make a set of target positions very dense. If we take a set from above and make it dense like {0, 1, 2, ..., 90, 91, ..., 180, ..., 0}, the above described disadvantage disappears, because only one degree is everything what separates two consecutive target positions and we can neglect with time intervals needed for acceleration and deceleration, because they are very small. In such a way it was possible to establish stabil smooth and slow motion for two step motors. Further decision to be taken was to decide in what way to make an array of target positions dense. While describing the interface chapter, we mentioned that we would make use of array which contains only information about control points, but it is not dense enough. In order to make it dense, two possibilities were considered: either to send discretization array that contains all information about one curve's side and not only control points, or to send array that consists of only control point positions and make it dense on the Arduino side. The last option has been chosen, because time needed to send more data via serial connection is much more than processing time of Arduino's CPU to achieve the same goal.

Another issue was lack of SRAM Arduino's memory, especially for Arduino Uno board. Since now the array of target positions should be very dense, we should store much more values as usual and carefully choose a data type for elements in this array. Choosing of smaller data type such as "byte" allows moving maximum up to 255 degrees, which might be not big enough to het high foam fragments resolution, whereas a bigger data type such as "unsigned int" would cause memory lack problems. This memory issue could have been solved by just sending each value separately without storing them in a big array, but again it would have taken much more time to communicate between a step motor, Arduino and processing. Moreover the acceptability of results because of these communication delays would be also under a question. Thus it has been considered to send only small array with control points, make it dense on the Arduino side and store all these values in array, which size should be carefully calculated. 

Last issue to solve was a problem of selecting the right value for acceleration. For example, if the left side has only one curve fragment, whereas the right side four, and both step motors should finish their cutting jobs by the time foam has reached it maximum height, it is obviously that two step motors should have different acceleration values. To determine the relation between a number of curve fragments and acceleration, a set of experiments has been done. Knowing a time interval needed to reach the maximum foam's height, a purpose of the first experiment was to determine by which acceleration value one step motor cuts exactly one curve fragment during this time. After that another set of experiments has been done to estimate what acceleration should be to produce two, four, eight and so on curve fragments within specified time. Experimental results showed the following relation: by increasing a number of curve fragments by two, appropriate acceleration value should be increased by four. The following formula summarizes this relation, defining a value for acceleration depending on a number of curve fragments:
double power = log(curves) / log(2);
double accel = BASE_ACCEL * pow(2, (power * 2));
where "curves" is a number of curve fragments and "BASE_ACCEL" is acceleration value needed to handle one curve fragment within specified time interval.

Experimental results using foam fabrication have shown a good level of acceptability and resolution, which can be seen in the video report of the project.
